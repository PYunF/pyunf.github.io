<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>黑马Java基础学习笔记</title>
    <url>/2021/03/23/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>



<h3 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h3><ol>
<li>Java内存划分<ol>
<li><strong>栈（Stack）：局部变量，方法运行一定在栈</strong></li>
<li><strong>堆（Heap）：new出来的东西</strong></li>
<li><strong>方法区：存储.class数据</strong></li>
<li>本地方法栈：与操作系统有关</li>
<li>寄存器：与CPU有关</li>
</ol>
</li>
<li>重载 ：名称相同，参数不同</li>
<li>数组<ul>
<li>引用类型，除了那8个基本类型 </li>
<li>引用类型变量都可以赋值null</li>
</ul>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li>继承的三个特点</li>
</ol>
<ul>
<li>一个类的直接父类只能有一个</li>
<li>Java语言可以多级继承</li>
<li>一个父类可以拥有多个子类</li>
</ul>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ol>
<li>三种使用方式</li>
</ol>
<p>​        用来访问父类内容</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>访问本类内容 三种使用方式</p>
<ol>
<li><p>在本类成员方法中，放文本类成员变量</p>
</li>
<li><p>在本类中访问本类的另一个方法</p>
</li>
<li><p>在本类构造方法中，访问本类另一个构造方法</p>
<ul>
<li>this(…)调用 也必须是 构造方法的第一个语句</li>
<li>super和this两种构造调用不能同时使用</li>
</ul>
</li>
</ol>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><ol>
<li>抽象的概念<ul>
<li>如果父类中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法</li>
<li>抽象类：抽象类的方法所在的类必须是抽象类才行</li>
</ul>
</li>
<li>如何使用抽象类和抽象方法<ol>
<li>不能直接创建new抽象类对象</li>
<li>必须用一个子类来继承 抽象父类</li>
<li>子类必须覆盖重写（实现）父类当中的所有的抽象方法</li>
</ol>
</li>
<li>注意事项<ol>
<li>抽象类不能创建对象</li>
<li>抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用</li>
<li>一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类</li>
<li>抽象类的子类，必须重写抽象父类中的所有抽象方法，除非该子类也是抽象类</li>
</ol>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li><p>接口注意事项</p>
<ul>
<li> 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</li>
<li>这两个关键字修饰符可以选择性忽略</li>
<li>方法三要素可以随意定义 </li>
</ul>
</li>
<li><p>使用步骤</p>
<ol>
<li>接口不能直接使用，必须有一个“实现类”来“实现”该接口。</li>
<li>  接口中的实现类必须覆盖重写（实现）接口中所有的抽象方法</li>
<li>创建实现类的对象，进行使用</li>
</ol>
</li>
<li><p>接口中的 默认方法，可以解决接口升级的问题</p>
<ol>
<li><p>default方法</p>
<ol>
<li><p>格式</p>
<p>public   default 返回值类型  方法名称(参数列表） {方法体}</p>
</li>
<li><p>默认方法也可以被覆盖重写</p>
</li>
</ol>
</li>
<li><p>static方法</p>
<ol>
<li><p>普通私有方法解决多个默认方法之间重复代码问题</p>
<ol>
<li><p>格式：</p>
<ol>
<li><p>private 返回值类型   方法名称（参数）{</p>
<p>  方法体  </p>
<p>}</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>静态私有方法，解决多个静态方法之间的重复代码问题</p>
<ol>
<li><p>格式</p>
<ol>
<li><p>private static 返回值类型   方法名称（参数）{</p>
<p>  方法体  </p>
<p>}</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>接口中的成员变量</p>
<ol>
<li> 只能使用 public static final  三个关键字来修饰</li>
<li>注意  一旦使用final关键字来修饰说明不可改变</li>
<li>接口中的常量，必须进行赋值，不能不赋值</li>
<li>接口中常量的名称使用完全大写的字母表示 ，使用下划线分割</li>
<li>格式<ol>
<li>public  static final  数据类型  常量  =  数据值</li>
<li>public  static final int CLASS_NUM_MY = 12;</li>
</ol>
</li>
</ol>
</li>
<li><p>接口的多继承</p>
<ol>
<li>类与类是单继承的，直接父类只有一个</li>
<li>类与接口是多实现的，一个类可以实现多个接口</li>
<li>接口和接口之间是多继承的</li>
<li>注意<ol>
<li>多个父接口当中的抽象方法冲突 ，没事</li>
<li>多个父接口当中的默认方法冲突，那么子接口必须进行默认方法的覆盖重写（而且带有default关键字）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol>
<li><p>面向对象的三大特征：封装性、继承性、多态性</p>
<ol>
<li><p>extends 继承或者implements实现是多态性的前提</p>
</li>
<li><p>一个对象拥有多种形态，这就是对象的多态性，如：一个学生既是学生也是人</p>
</li>
<li><p>代码中体现多态性，其实就是：父类引用指向子类对象</p>
<pre><code> 1. 格式
      1. 父类名称  对象名 = new  子类名称();
      2. 接口名称 对象名 = new 实现类名称();
2. 注意：
 1. 没有是覆盖重写是父
 2. 有覆盖重写是子

4. 在多态的成员方法当中，成员方法的访问规则是

1. 看new的是谁，谁优先用谁，没有则向上找
2. 口诀：
 1. 成员变量：编译看左边，运行还看左边
 2. 成员方法：编译看左边，运行看右边

5. 使用多态的好处

6. 向上转型和向下转型

1. 向上转型

 1. 其实 就是多态写法
 2. 格式 ：父类  对象名 =  new  子类名称；
 3. 含义：右侧创建一个子类对象，拿它当作父类来使用
 4. 注意事项：向上转型一定是安全的，从小范围转向了大范围
        1. 类似于自动类型装换如 int--》转double
 5. 弊端：一旦向上转型为父类则无法调用子类原本特有的内容
        1. 解决方案：还原（向下转型）

2. 向下转型

 1. 格式：子类名称 对象名 =  （子类名称 ）父类对象；

 2. 含义：将父类对象，还原成为==本来==的子类对象

 3. 注意事项

        1. 必须保证对象本来创建的时候就是猫，才能向下转型为猫
        2. 如果对象创建的时候本来不是猫，现在非要向下转型为猫，就会运行报错（ClassCastException）

 4. instanceof

        1. 知道父类引用的对象，本来是什么子类

        2. 格式

            1. animal  instanceof cat会得到一个Boolean值
</code></pre>
<p> ​           </p>
</li>
</ol>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol>
<li><p>final关键字代表最终、不可改变的。</p>
</li>
<li><p>常见四种用法</p>
<ol>
<li>可以用来修饰一个类</li>
<li>可以用来修饰一个方法</li>
<li>可以用来修饰一个局部变量</li>
<li>可以用来修饰一个成员变量</li>
</ol>
</li>
<li><p>格式</p>
<ol>
<li><p>修饰类</p>
<ol>
<li><p>```java<br>public final class (类名称) {</p>
<pre><code>//...
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      含义：当前这个类不能有任何子类。</span><br><span class="line"></span><br><span class="line">      注意：如果一个类是final的，那么其中所有的成员方法都无法进行覆盖重写</span><br><span class="line"></span><br><span class="line">   2. 修饰方法</span><br><span class="line"></span><br><span class="line">      1. 当final关键字来修饰一个方法的时候，这个方法就是最终方法，也不能被覆盖重写</span><br><span class="line">      2. 注意事项</span><br><span class="line">         1. 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾</span><br><span class="line"></span><br><span class="line">   3. 修饰一个局部变量</span><br><span class="line"></span><br><span class="line">      1. 一旦使用final来修饰局部变量，难么这个变量就不能进行更改</span><br><span class="line">      2. 对于基本类型来说，不可变说的是变量当中的数据不可变</span><br><span class="line">      3. 对于引用类型来说，不可变说的是变量当中的地址值不可变</span><br><span class="line"></span><br><span class="line">   4. 修饰成员变量</span><br><span class="line"></span><br><span class="line">      1. 变量不可变，成员变量具有默认值，必须手动赋值</span><br><span class="line">      2. 要么直接赋值，要么使用构造方法赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 权限修饰符</span><br><span class="line"></span><br><span class="line">1. 四种权限修饰符（权限从小到大排序）</span><br><span class="line">   1. public</span><br><span class="line">   2. protected</span><br><span class="line">   3. （default）</span><br><span class="line">   4. private</span><br><span class="line">2. 同一个类：都可以访问 </span><br><span class="line">3. 同一个包：除了private都可以访问</span><br><span class="line">4. 不同包子类：除了default和private都可以访问</span><br><span class="line">5. 不同包非子类：只有public可以访问</span><br><span class="line"></span><br><span class="line">### 内部类</span><br><span class="line"></span><br><span class="line">1. 如果一个事物内部包含另一个事务，那么这就是一个类内部包含了另一个类</span><br><span class="line"></span><br><span class="line">   1. 如：汽车和发动机</span><br><span class="line"></span><br><span class="line">2. 分类</span><br><span class="line"></span><br><span class="line">   1. 成员内部类</span><br><span class="line"></span><br><span class="line">      1. 定义格式</span><br><span class="line"></span><br><span class="line">         1. &#96;&#96;&#96;java</span><br><span class="line">            修饰符 class 类名称&#123;</span><br><span class="line">                修饰符  class 内部类名称&#123;</span><br><span class="line">                    &#x2F;&#x2F;...</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>注意：内用外，随意访问；外用内，需要内部类对象。</p>
</li>
<li><p>如何使用内部类</p>
<ol>
<li>间接方式：在外部类的方法中，使用内部类，然后main知识调用外部类</li>
<li>直接方式：公式：<ol>
<li>类名称 对象名= new 类名称</li>
<li>外部类名称.内部类名称  对象名   = new  外部类名称().new  内部类名称();</li>
</ol>
</li>
</ol>
</li>
<li><p>内部类方法的局部变量</p>
<ol>
<li>局部变量 ，就近原则</li>
<li>如果出现重名现象，内部类名称为this.内部类成员变量名</li>
<li>如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>局部内部类（包括匿名内部类）</p>
<ol>
<li><p>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类，局部：只有当前所属方法才能使用他，除了这个方法外面就不能用了</p>
</li>
<li><p>格式</p>
<ol>
<li>```java<br>修饰符 class 外部类名称{<pre><code>修饰符  返回值类型  外部类方法名称(参数列表)&#123;
    class 局部名称类型&#123;
        //...
    &#125;
&#125;
</code></pre>
}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   3. 定义一个类时，权限修饰符规则：</span><br><span class="line"></span><br><span class="line">      1. 外部类：public.&#x2F;(default)、</span><br><span class="line">      2. 成员内部类：public &#x2F; protected &#x2F; (default) &#x2F; private</span><br><span class="line">      3. 局部内部类：什么都不写</span><br><span class="line"></span><br><span class="line">   4. 注意事项</span><br><span class="line"></span><br><span class="line">      1.  从Java8开始，只要局部变量事实不变，难么final关键字可以省略</span><br><span class="line">      2. 原因</span><br><span class="line">         1. new出来的对象是在对内存中</span><br><span class="line">         2. 局部变量是跟着方法走的，在栈当中</span><br><span class="line">         3. 方法运行结束之后，立即出栈，局部变量就会立刻消失</span><br><span class="line">         4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失</span><br><span class="line"></span><br><span class="line">3. 匿名内部类</span><br><span class="line"></span><br><span class="line">   1. 如果接口的实现类或者父类的子类，只需要使用唯一的一次，这种情况下将就可以省略该类的定义，而改为使用&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;。</span><br><span class="line"></span><br><span class="line">   2. 格式</span><br><span class="line"></span><br><span class="line">      1. &#96;&#96;&#96;java</span><br><span class="line">         接口名称  对象名  &#x3D;  new 接口名称()&#123;</span><br><span class="line">             &#x2F;&#x2F;覆盖重写所有抽象方法</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li>对格式进行解析“new 接口名称(){…}”<ol>
<li>new 代表创建对象的动作</li>
<li>接口名称就是匿名内部类需要实现那个接口</li>
<li>{…}这才是匿名内部类的内容</li>
</ol>
</li>
<li>匿名内部类，在创建对象的时候，只能使用唯一一次，如果希望多次创建对象，而且类的内容一样的话，就需使用要实现类</li>
<li>匿名对象，在调用方法的时候只能 调用唯一一次，如果希望多次调用，则必须给对象起个名字</li>
<li>匿名内部类是省略了（实现类/子类名称）,匿名对象是省略了对象；这两者是不一样的</li>
</ol>
</li>
<li><p>类作为成员变量类型</p>
<ol>
<li>String也是一个类</li>
</ol>
</li>
<li><p>接口作为成员变量类型</p>
</li>
<li><p>接口作为成员的方法或者返回值</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
